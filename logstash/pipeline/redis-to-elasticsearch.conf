input {
  redis {
    host => "redis"
    port => 6379
    password => "redis_password_123"
    key => "iot:data"
    data_type => "list"
    batch_count => 10
    codec => plain {
      charset => "UTF-8"
    }
    threads => 2
    # Tag to identify Redis messages and prevent drops from other pipeline filters
    tags => ["from_redis"]
  }
}

filter {
  # Only process messages from Redis (skip if no from_redis tag)
  if "from_redis" not in [tags] {
    drop { }
  }
  
  # Parse JSON du message principal
  json {
    source => "message"
    target => "parsed"
  }
  
  # Extraire les métadonnées du fichier uploadé
  if [parsed][source_file] {
    mutate {
      add_field => {
        "source_file" => "%{[parsed][source_file]}"
        "file_type" => "%{[parsed][file_type]}"
        "data_type" => "%{[parsed][data_type]}"
        "upload_timestamp" => "%{[parsed][upload_timestamp]}"
      }
    }
  }
  
  # Extraire les données réelles (dans le champ 'data')
  if [parsed][data] {
    ruby {
      code => "
        data = event.get('[parsed][data]')
        if data.is_a?(Hash)
          data.each do |key, value|
            event.set(key, value)
          end
        end
      "
    }
  }
  
  # Convertir les champs numériques communs
  if [temperature] {
    mutate {
      convert => { "temperature" => "float" }
    }
  }
  
  if [humidity] {
    mutate {
      convert => { "humidity" => "float" }
    }
  }
  
  if [battery_level] {
    mutate {
      convert => { "battery_level" => "integer" }
    }
  }
  
  if [personnes_presentes] {
    mutate {
      convert => { "personnes_presentes" => "integer" }
    }
  }
  
  if [taux_occupation] {
    mutate {
      convert => { "taux_occupation" => "float" }
    }
  }
  
  if [consommation_kwh] {
    mutate {
      convert => { "consommation_kwh" => "float" }
    }
  }
  
  if [cout_euro] {
    mutate {
      convert => { "cout_euro" => "float" }
    }
  }
  
  if [vie_restante] {
    mutate {
      convert => { "vie_restante" => "integer" }
    }
  }
  
  if [duree_intervention_estimee] {
    mutate {
      convert => { "duree_intervention_estimee" => "integer" }
    }
  }
  
  if [cout_estime] {
    mutate {
      convert => { "cout_estime" => "float" }
    }
  }
  
  # Parser le timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd'T'HH:mm:ssZ", "YYYY-MM-dd'T'HH:mm:ss.SSSZ" ]
      target => "@timestamp"
      timezone => "UTC"
    }
  } else if [upload_timestamp] {
    date {
      match => [ "upload_timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Nettoyer les champs temporaires
  mutate {
    remove_field => ["parsed", "message"]
  }
}

output {
  # Only output Redis messages
  if "from_redis" in [tags] {
    # Debug dans stdout pour troubleshooting
    stdout {
      codec => json_lines
    }
  
    # Router vers les bons index Elasticsearch selon data_type
    if [data_type] == "alertes" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-alertes"
      # Ne pas forcer le document_id pour éviter les écrasements
      # Elasticsearch génèrera un ID unique automatiquement
    }
  }
  else if [data_type] == "capteurs" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-capteurs"
    }
  }
  else if [data_type] == "consommation" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-consommation"
    }
  }
  else if [data_type] == "occupation" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-occupation"
    }
  }
  else if [data_type] == "maintenance" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-maintenance"
    }
  }
  else {
    # Fallback pour données inconnues
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "iot-unknown-%{+YYYY.MM.dd}"
    }
  }
  }  # Fin du if "from_redis" in [tags]
}
